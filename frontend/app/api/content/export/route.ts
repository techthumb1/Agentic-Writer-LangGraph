// app/api/content/export/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

// Validation schema for export request
const exportSchema = z.object({
  title: z.string().min(1),
  content: z.string().min(1),
  format: z.enum(['markdown', 'html', 'pdf']),
  templateId: z.string().optional(),
  styleProfile: z.string().optional(),
});

// Helper function to convert markdown to HTML
function markdownToHtml(content: string): string {
  return content
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
    .replace(/\*(.*)\*/gim, '<em>$1</em>')
    .replace(/\n\n/gim, '</p><p>')
    .replace(/\n/gim, '<br>')
    .replace(/^(.*)$/gim, '<p>$1</p>')
    .replace(/<p><\/p>/gim, '')
    .replace(/<p><h([1-6])>/gim, '<h$1>')
    .replace(/<\/h([1-6])><\/p>/gim, '</h$1>');
}

// Helper function to create professional HTML template
type Metadata = {
  wordCount?: number;
  readingTime?: number;
  qualityScore?: number;
};

function createHtmlTemplate(title: string, content: string, metadata?: Metadata): string {
  const htmlContent = markdownToHtml(content);
  
  return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        strong {
            color: #2c3e50;
        }
        em {
            color: #7f8c8d;
        }
        .metadata {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-top: 30px;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #bdc3c7;
            text-align: center;
            font-size: 0.8em;
            color: #95a5a6;
        }
        @media print {
            body {
                padding: 20px;
            }
            .metadata {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <h1>${title}</h1>
    ${htmlContent}
    
    ${metadata ? `
    <div class="metadata">
        <strong>Document Information:</strong><br>
        Word Count: ${metadata.wordCount || 'N/A'}<br>
        Reading Time: ${metadata.readingTime || 'N/A'} minutes<br>
        Quality Score: ${metadata.qualityScore || 'N/A'}%<br>
        Generated: ${new Date().toLocaleDateString()}
    </div>
    ` : ''}
    
    <div class="footer">
        Generated by WriterzRoom
    </div>
</body>
</html>`;
}

// POST - Export content in specified format
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Export request received:', { format: body.format, title: body.title });
    
    // Validate the request body
    const validatedData = exportSchema.parse(body);
    const { title, format, templateId, styleProfile } = validatedData;
    let { content } = validatedData;

    // Handle templateId: you could load a template by ID and apply it to the content
    // For demonstration, we'll just append template info if provided
    if (templateId) {
      content = `<!-- Template: ${templateId} -->\n` + content;
    }

    // Handle styleProfile: you could apply different styles based on the profile
    // For demonstration, we'll just add a comment or modify the HTML template
    if (styleProfile && format === 'html') {
      // Example: inject a CSS class or style block
      content = `<div class="style-${styleProfile}">\n${content}\n</div>`;
    }
    
    let exportedContent: string;
    let contentType: string;
    let fileExtension: string;
    
    switch (format) {
      case 'markdown':
        exportedContent = `# ${title}\n\n${content}`;
        contentType = 'text/markdown';
        fileExtension = 'md';
        break;
        
      case 'html':
        exportedContent = createHtmlTemplate(title, content, body.metadata);
        contentType = 'text/html';
        fileExtension = 'html';
        break;
        
      case 'pdf':
        // For PDF, we'll return HTML that can be converted to PDF on the client side
        exportedContent = createHtmlTemplate(title, content, body.metadata);
        contentType = 'text/html';
        fileExtension = 'html';
        break;
        
      default:
        throw new Error('Unsupported export format');
    }
    
    // Create filename
    const sanitizedTitle = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedTitle}.${fileExtension}`;
    
    console.log('Export successful:', { filename, contentLength: exportedContent.length });
    
    return new NextResponse(exportedContent, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Cache-Control': 'no-cache',
      },
    });
    
  } catch (error) {
    console.error('Export error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Invalid export request',
        details: error.errors
      }, { status: 400 });
    }
    
    return NextResponse.json({
      success: false,
      error: 'Export failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

// GET - Get export formats
export async function GET() {
  return NextResponse.json({
    success: true,
    formats: [
      {
        id: 'markdown',
        name: 'Markdown',
        description: 'Plain text with markdown formatting',
        extension: 'md'
      },
      {
        id: 'html',
        name: 'HTML',
        description: 'Professional HTML document',
        extension: 'html'
      },
      {
        id: 'pdf',
        name: 'PDF',
        description: 'PDF document (requires client-side conversion)',
        extension: 'pdf'
      }
    ]
  });
}