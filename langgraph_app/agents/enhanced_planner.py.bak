# langgraph_app/agents/enhanced_planner.py

import os
import logging
import time
from typing import Dict, Any, List, Tuple
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum

from langchain_core.runnables import RunnableLambda
from dotenv import load_dotenv

load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ContentType(Enum):
    TECHNICAL_ARTICLE = "technical_article"
    TUTORIAL = "tutorial"
    RESEARCH_REVIEW = "research_review"
    OPINION_PIECE = "opinion_piece"
    NEWS_ANALYSIS = "news_analysis"
    CASE_STUDY = "case_study"
    WHITEPAPER = "whitepaper"
    BLOG_POST = "blog_post"
    SOCIAL_MEDIA = "social_media"
    NEWSLETTER = "newsletter"

class Audience(Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"
    GENERAL_PUBLIC = "general_public"
    TECHNICAL_PROFESSIONALS = "technical_professionals"
    BUSINESS_LEADERS = "business_leaders"
    RESEARCHERS = "researchers"
    STUDENTS = "students"

class ContentComplexity(Enum):
    SIMPLE = "simple"
    MODERATE = "moderate"
    COMPLEX = "complex"
    HIGHLY_TECHNICAL = "highly_technical"

class PlanningApproach(Enum):
    RESEARCH_DRIVEN = "research_driven"
    NARRATIVE_FOCUSED = "narrative_focused"
    TUTORIAL_BASED = "tutorial_based"
    ANALYSIS_HEAVY = "analysis_heavy"
    OPINION_CENTRIC = "opinion_centric"
    DATA_DRIVEN = "data_driven"

@dataclass
class ContentStructure:
    """Defines the structure of content"""
    introduction: Dict[str, Any] = field(default_factory=dict)
    main_sections: List[Dict[str, Any]] = field(default_factory=list)
    conclusion: Dict[str, Any] = field(default_factory=dict)
    appendices: List[Dict[str, Any]] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ResearchRequirements:
    """Research requirements for content planning"""
    primary_topics: List[str] = field(default_factory=list)
    secondary_topics: List[str] = field(default_factory=list)
    required_sources: List[str] = field(default_factory=list)
    source_types: List[str] = field(default_factory=list)
    depth_level: str = "moderate"
    recency_requirement: str = "within_1_year"
    credibility_threshold: str = "high"

@dataclass
class StyleRequirements:
    """Style and tone requirements"""
    writing_style: str = "professional"
    tone: str = "informative"
    formality_level: str = "formal"
    technical_depth: str = "moderate"
    use_examples: bool = True
    include_code_snippets: bool = False
    include_diagrams: bool = False
    include_citations: bool = True

@dataclass
class SEORequirements:
    """SEO optimization requirements"""
    target_keywords: List[str] = field(default_factory=list)
    keyword_density: float = 0.02
    meta_description_length: int = 160
    title_length: int = 60
    header_structure: bool = True
    internal_linking: bool = True
    external_linking: bool = True
    image_optimization: bool = True

@dataclass
class ContentPlan:
    """Comprehensive content plan"""
    topic: str = ""
    content_type: ContentType = ContentType.BLOG_POST
    target_audience: Audience = Audience.GENERAL_PUBLIC
    complexity: ContentComplexity = ContentComplexity.MODERATE
    approach: PlanningApproach = PlanningApproach.RESEARCH_DRIVEN
    estimated_length: int = 1500
    estimated_read_time: int = 6
    structure: ContentStructure = field(default_factory=ContentStructure)
    research_requirements: ResearchRequirements = field(default_factory=ResearchRequirements)
    style_requirements: StyleRequirements = field(default_factory=StyleRequirements)
    seo_requirements: SEORequirements = field(default_factory=SEORequirements)
    timeline: Dict[str, Any] = field(default_factory=dict)
    success_metrics: Dict[str, Any] = field(default_factory=dict)
    creation_metadata: Dict[str, Any] = field(default_factory=dict)

class ContentAnalyzer:
    """Analyzes topics and determines optimal content approach"""
    
    def __init__(self, model_registry=None):
        self.model_registry = model_registry
    
    def analyze_topic(self, topic: str, dynamic_params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Analyze topic to determine content characteristics"""
        try:
            if not dynamic_params:
                dynamic_params = {}
            
            topic_lower = topic.lower()
            
            # Determine content characteristics
            content_type = self._determine_content_type(topic_lower, dynamic_params)
            audience = self._determine_audience(topic_lower, dynamic_params)
            complexity = self._determine_complexity(topic_lower, dynamic_params)
            approach = self._determine_approach(topic_lower, dynamic_params)
            estimated_length, read_time = self._estimate_length_and_time(content_type, complexity)
            
            return {
                "content_type": content_type,
                "target_audience": audience,
                "complexity": complexity,
                "approach": approach,
                "estimated_length": estimated_length,
                "estimated_read_time": read_time,
                "analysis_confidence": self._calculate_confidence(topic, dynamic_params)
            }
            
        except Exception as e:
            logger.error(f"Topic analysis failed: {e}")
            return {
                "content_type": ContentType.BLOG_POST,
                "target_audience": Audience.GENERAL_PUBLIC,
                "complexity": ContentComplexity.MODERATE,
                "approach": PlanningApproach.RESEARCH_DRIVEN,
                "estimated_length": 1500,
                "estimated_read_time": 6,
                "analysis_confidence": 0.5
            }
    
    def _determine_content_type(self, topic: str, params: Dict) -> ContentType:
        """Determine content type from topic and parameters"""
        if "content_type" in params:
            try:
                return ContentType(params["content_type"].lower())
            except ValueError:
                pass
        
        # Topic-based detection
        if any(word in topic for word in ["tutorial", "how to", "guide", "step by step"]):
            return ContentType.TUTORIAL
        elif any(word in topic for word in ["review", "analysis", "evaluation"]):
            return ContentType.RESEARCH_REVIEW
        elif any(word in topic for word in ["opinion", "thoughts", "perspective"]):
            return ContentType.OPINION_PIECE
        elif any(word in topic for word in ["news", "latest", "update", "breaking"]):
            return ContentType.NEWS_ANALYSIS
        elif any(word in topic for word in ["case study", "implementation", "example"]):
            return ContentType.CASE_STUDY
        elif any(word in topic for word in ["technical", "deep dive", "architecture"]):
            return ContentType.TECHNICAL_ARTICLE
        else:
            return ContentType.BLOG_POST
    
    def _determine_audience(self, topic: str, params: Dict) -> Audience:
        """Determine target audience"""
        if "target_audience" in params:
            try:
                return Audience(params["target_audience"].lower())
            except ValueError:
                pass
        
        if any(word in topic for word in ["beginner", "introduction", "basics", "101"]):
            return Audience.BEGINNER
        elif any(word in topic for word in ["advanced", "expert", "professional"]):
            return Audience.ADVANCED
        elif any(word in topic for word in ["technical", "engineering", "developer"]):
            return Audience.TECHNICAL_PROFESSIONALS
        elif any(word in topic for word in ["business", "executive", "strategy"]):
            return Audience.BUSINESS_LEADERS
        elif any(word in topic for word in ["research", "academic", "study"]):
            return Audience.RESEARCHERS
        else:
            return Audience.GENERAL_PUBLIC
    
    def _determine_complexity(self, topic: str, params: Dict) -> ContentComplexity:
        """Determine content complexity"""
        if "complexity" in params:
            try:
                return ContentComplexity(params["complexity"].lower())
            except ValueError:
                pass
        
        if any(word in topic for word in ["simple", "basic", "easy", "beginner"]):
            return ContentComplexity.SIMPLE
        elif any(word in topic for word in ["advanced", "complex", "sophisticated"]):
            return ContentComplexity.COMPLEX
        elif any(word in topic for word in ["technical", "algorithmic", "mathematical"]):
            return ContentComplexity.HIGHLY_TECHNICAL
        else:
            return ContentComplexity.MODERATE
    
    def _determine_approach(self, topic: str, params: Dict) -> PlanningApproach:
        """Determine planning approach"""
        if "approach" in params:
            try:
                return PlanningApproach(params["approach"].lower())
            except ValueError:
                pass
        
        if any(word in topic for word in ["tutorial", "how to", "guide"]):
            return PlanningApproach.TUTORIAL_BASED
        elif any(word in topic for word in ["analysis", "review", "evaluation"]):
            return PlanningApproach.ANALYSIS_HEAVY
        elif any(word in topic for word in ["opinion", "thoughts", "perspective"]):
            return PlanningApproach.OPINION_CENTRIC
        elif any(word in topic for word in ["data", "statistics", "metrics"]):
            return PlanningApproach.DATA_DRIVEN
        elif any(word in topic for word in ["story", "narrative", "journey"]):
            return PlanningApproach.NARRATIVE_FOCUSED
        else:
            return PlanningApproach.RESEARCH_DRIVEN
    
    def _estimate_length_and_time(self, content_type: ContentType, complexity: ContentComplexity) -> Tuple[int, int]:
        """Estimate content length and reading time"""
        base_lengths = {
            ContentType.TECHNICAL_ARTICLE: 2500,
            ContentType.TUTORIAL: 2000,
            ContentType.RESEARCH_REVIEW: 3000,
            ContentType.OPINION_PIECE: 1200,
            ContentType.NEWS_ANALYSIS: 1000,
            ContentType.CASE_STUDY: 2200,
            ContentType.WHITEPAPER: 4000,
            ContentType.BLOG_POST: 1500,
            ContentType.SOCIAL_MEDIA: 300,
            ContentType.NEWSLETTER: 800
        }
        
        complexity_multipliers = {
            ContentComplexity.SIMPLE: 0.8,
            ContentComplexity.MODERATE: 1.0,
            ContentComplexity.COMPLEX: 1.3,
            ContentComplexity.HIGHLY_TECHNICAL: 1.6
        }
        
        base_length = base_lengths.get(content_type, 1500)
        multiplier = complexity_multipliers.get(complexity, 1.0)
        estimated_length = int(base_length * multiplier)
        read_time = max(1, estimated_length // 200)  # 200 words per minute
        
        return estimated_length, read_time
    
    def _calculate_confidence(self, topic: str, params: Dict) -> float:
        """Calculate confidence score for analysis"""
        confidence = 0.7  # Base confidence
        
        if "content_type" in params:
            confidence += 0.1
        if "target_audience" in params:
            confidence += 0.1
        if "complexity" in params:
            confidence += 0.1
        
        topic_lower = topic.lower()
        if any(word in topic_lower for word in ["tutorial", "guide", "how to", "introduction"]):
            confidence += 0.05
        
        return min(1.0, confidence)

class IntelligentPlannerAgent:
    """Intelligent Planner Agent that creates comprehensive content plans"""
    
    def __init__(self, model_registry=None):
        self.model_registry = model_registry
        self.content_analyzer = ContentAnalyzer(model_registry)
    
    async def intelligent_plan(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Main planning function with intelligent analysis"""
        start_time = time.time()
        
        try:
            # Extract input parameters with robust fallbacks
            topic = (
                state.get("topic") or 
                state.get("template_config", {}).get("topic") or
                state.get("dynamic_parameters", {}).get("topic") or
                state.get("template", "")
            )
            # Create meaningful topic if none provided
            if not topic:
                template_name = state.get("template", "content")
                style_name = state.get("style_profile", "")
                topic = f"{template_name.replace('_', ' ').title()} content"
                if style_name:
                    topic += f" in {style_name.replace('_', ' ')} style"
            
            dynamic_params = state.get("dynamic_parameters", {})
            style_profile_id = state.get("style_profile", "jason")
            
            # Load the actual style profile
            try:
                from langgraph_app.style_profile_loader import style_profile_loader
                style_profile = style_profile_loader.get_profile(style_profile_id)
                if style_profile is None:
                    style_profile = {}  # fallback to empty dict
            except Exception as e:
                logger.warning(f"Failed to load style profile '{style_profile_id}': {e}")
                style_profile = {}  # fallback to empty dict
            
            logger.info(f"Starting intelligent planning for topic: {topic}")
            
            # Analyze topic to determine content characteristics
            analysis_result = self.content_analyzer.analyze_topic(topic, dynamic_params)
            
            # Create comprehensive content plan
            content_plan = ContentPlan(
                topic=topic,
                content_type=analysis_result["content_type"],
                target_audience=analysis_result["target_audience"],
                complexity=analysis_result["complexity"],
                approach=analysis_result["approach"],
                estimated_length=analysis_result["estimated_length"],
                estimated_read_time=analysis_result["estimated_read_time"]
            )
            
            # Generate structure and requirements
            content_plan.structure = self._generate_structure(content_plan)
            content_plan.research_requirements = self._generate_research_requirements(content_plan, dynamic_params)
            content_plan.style_requirements = self._generate_style_requirements(content_plan, style_profile)
            content_plan.seo_requirements = self._generate_seo_requirements(content_plan, dynamic_params)
            content_plan.timeline = self._generate_timeline(content_plan)
            content_plan.success_metrics = self._generate_success_metrics(content_plan)
            
            # Add creation metadata
            planning_time_ms = int((time.time() - start_time) * 1000)
            content_plan.creation_metadata = {
                "planner_version": "2.0",
                "created_at": datetime.now().isoformat(),
                "planning_time_ms": planning_time_ms,
                "input_topic": topic,
                "dynamic_parameters": dynamic_params,
                "style_profile_applied": bool(style_profile)
            }
            
            # Calculate confidence and generate guidance
            confidence_score = min(1.0, analysis_result["analysis_confidence"] + 0.2)
            recommendations = self._generate_recommendations(content_plan)
            
            # Create comprehensive response
            response = {
                "content_plan": self._serialize_content_plan(content_plan),
                "planning_metadata": {
                    "confidence_score": confidence_score,
                    "planning_time_ms": planning_time_ms,
                    "analysis_confidence": analysis_result["analysis_confidence"]
                },
                "planning_result": {
                    "status": "completed",
                    "reasoning": self._generate_reasoning(content_plan, analysis_result),
                    "recommendations": recommendations
                },
                "research_guidance": {
                    "primary_topics": content_plan.research_requirements.primary_topics,
                    "secondary_topics": content_plan.research_requirements.secondary_topics,
                    "source_requirements": content_plan.research_requirements.required_sources,
                    "depth_level": content_plan.research_requirements.depth_level,
                    "recency_requirement": content_plan.research_requirements.recency_requirement
                },
                "structure_outline": {
                    "introduction": content_plan.structure.introduction,
                    "main_sections": content_plan.structure.main_sections,
                    "conclusion": content_plan.structure.conclusion,
                    "total_estimated_length": content_plan.estimated_length
                },
                "style_guidance": {
                    "writing_style": content_plan.style_requirements.writing_style,
                    "tone": content_plan.style_requirements.tone,
                    "formality_level": content_plan.style_requirements.formality_level,
                    "technical_depth": content_plan.style_requirements.technical_depth,
                    "include_examples": content_plan.style_requirements.use_examples,
                    "include_code": content_plan.style_requirements.include_code_snippets,
                    "include_diagrams": content_plan.style_requirements.include_diagrams,
                    "include_citations": content_plan.style_requirements.include_citations
                }
            }
            
            logger.info(f"Planning completed successfully in {planning_time_ms}ms with confidence {confidence_score:.2f}")
            return response
            
        except Exception as e:
            logger.error(f"Planning failed: {e}")
            return {
                "content_plan": {},
                "planning_metadata": {
                    "confidence_score": 0.0,
                    "planning_time_ms": int((time.time() - start_time) * 1000),
                    "error": str(e)
                },
                "planning_result": {
                    "status": "failed",
                    "error": str(e),
                    "reasoning": f"Planning failed due to: {str(e)}"
                }
            }
    
    def _generate_structure(self, content_plan: ContentPlan) -> ContentStructure:
        """Generate content structure"""
        structure = ContentStructure()
        
        structure.introduction = {
            "hook": {"type": "question" if content_plan.target_audience in [Audience.BEGINNER, Audience.GENERAL_PUBLIC] else "statement"},
            "context": {"background_info": True, "current_state": True},
            "preview": {"what_readers_will_learn": True},
            "estimated_length": min(200, content_plan.estimated_length // 10)
        }
        
        # Generate main sections based on approach
        if content_plan.approach == PlanningApproach.TUTORIAL_BASED:
            structure.main_sections = [
                {"title": "Prerequisites and Setup", "type": "preparation", "estimated_length": content_plan.estimated_length // 8},
                {"title": "Step-by-Step Implementation", "type": "implementation", "estimated_length": content_plan.estimated_length // 2},
                {"title": "Testing and Validation", "type": "validation", "estimated_length": content_plan.estimated_length // 6}
            ]
        else:
            structure.main_sections = [
                {"title": "Understanding the Basics", "type": "fundamentals", "estimated_length": content_plan.estimated_length // 4},
                {"title": "Practical Applications", "type": "application", "estimated_length": content_plan.estimated_length // 3},
                {"title": "Best Practices", "type": "guidance", "estimated_length": content_plan.estimated_length // 3}
            ]
        
        structure.conclusion = {
            "summary": {"key_points_recap": True, "main_takeaways": True},
            "call_to_action": {"next_steps": True},
            "estimated_length": min(300, content_plan.estimated_length // 8)
        }
        
        structure.metadata = {
            "total_sections": len(structure.main_sections),
            "estimated_length": content_plan.estimated_length,
            "generated_at": datetime.now().isoformat()
        }
        
        return structure
    
    def _generate_research_requirements(self, content_plan: ContentPlan, dynamic_params: Dict[str, Any]) -> ResearchRequirements:
        """Generate research requirements"""
        primary_topics = [content_plan.topic]
        words = content_plan.topic.lower().split()
        for word in words:
            if len(word) > 4:
                primary_topics.append(word)
        
        return ResearchRequirements(
            primary_topics=primary_topics[:5],
            secondary_topics=["best practices", "examples", "case studies"],
            required_sources=["industry articles", "expert opinions"],
            source_types=["web articles", "blog posts"],
            depth_level="moderate",
            recency_requirement="within_1_year",
            credibility_threshold="moderate"
        )
    
    def _generate_style_requirements(self, content_plan: ContentPlan, style_profile: Dict[str, Any]) -> StyleRequirements:
        """Generate style requirements"""
        requirements = StyleRequirements()
        
        # Apply style profile overrides if available
        if style_profile:
            if "writing_style" in style_profile:
                requirements.writing_style = style_profile["writing_style"]
            if "tone" in style_profile:
                requirements.tone = style_profile["tone"]
        
        return requirements
    
    def _generate_seo_requirements(self, content_plan: ContentPlan, dynamic_params: Dict[str, Any]) -> SEORequirements:
        """Generate SEO requirements"""
        keywords = [content_plan.topic]
        if "keywords" in dynamic_params:
            keywords.extend(dynamic_params["keywords"])
        
        return SEORequirements(
            target_keywords=keywords[:5],
            keyword_density=0.02,
            meta_description_length=160,
            title_length=60,
            header_structure=True,
            internal_linking=True,
            external_linking=True,
            image_optimization=True
        )
    
    def _generate_timeline(self, content_plan: ContentPlan) -> Dict[str, Any]:
        """Generate content creation timeline"""
        base_hours = {
            "research": max(1, content_plan.estimated_length // 300),
            "writing": max(2, content_plan.estimated_length // 200),
            "editing": max(1, content_plan.estimated_length // 500),
            "review": 1
        }
        
        total_hours = sum(base_hours.values())
        return {
            **base_hours,
            "total_estimated_hours": total_hours,
            "estimated_days": max(1, total_hours // 6)
        }
    
    def _generate_success_metrics(self, content_plan: ContentPlan) -> Dict[str, Any]:
        """Generate success metrics"""
        return {
            "length_target": {
                "minimum": int(content_plan.estimated_length * 0.9),
                "target": content_plan.estimated_length,
                "maximum": int(content_plan.estimated_length * 1.1)
            },
            "readability": {"target_reading_level": "10th grade", "sentence_length_max": 25},
            "engagement": {"estimated_read_time": content_plan.estimated_read_time, "examples_required": True}
        }
    
    def _generate_recommendations(self, content_plan: ContentPlan) -> List[str]:
        """Generate recommendations"""
        recommendations = []
        
        if content_plan.estimated_length > 3000:
            recommendations.append("Consider breaking into multiple sections for better readability")
        
        if content_plan.target_audience == Audience.BEGINNER:
            recommendations.append("Include plenty of examples and avoid jargon")
        
        if content_plan.content_type == ContentType.TUTORIAL:
            recommendations.append("Include step-by-step instructions with examples")
        
        return recommendations
    
    # Fix for enhanced_planner.py - Variable Scope Issue

# The issue is in the enhanced_planner.py file where style_profile variable is not properly initialized
# Here's the fix for the variable scope error:

    def _generate_reasoning(self, content_plan: ContentPlan, analysis_result: Dict[str, Any]) -> str:
        """Generate reasoning explanation"""
        return (f"Based on topic analysis, this content is best suited as a {content_plan.content_type.value} "
                f"targeting {content_plan.target_audience.value} audience with {content_plan.complexity.value} complexity. "
                f"Estimated {content_plan.estimated_length} words for approximately {content_plan.estimated_read_time} minute read.")
    
    def _serialize_content_plan(self, content_plan: ContentPlan) -> Dict[str, Any]:
        """Serialize content plan to dictionary"""
        return {
            "topic": content_plan.topic,
            "content_type": content_plan.content_type.value,
            "target_audience": content_plan.target_audience.value,
            "complexity": content_plan.complexity.value,
            "approach": content_plan.approach.value,
            "estimated_length": content_plan.estimated_length,
            "estimated_read_time": content_plan.estimated_read_time,
            "timeline": content_plan.timeline,
            "success_metrics": content_plan.success_metrics,
            "creation_metadata": content_plan.creation_metadata
        }

# Export the agent function
async def _enhanced_planner_fn(state: dict) -> dict:
    """Enhanced planner agent function for LangGraph workflow"""
    planner_agent = IntelligentPlannerAgent()
    return await planner_agent.intelligent_plan(state)

planner = RunnableLambda(_enhanced_planner_fn)