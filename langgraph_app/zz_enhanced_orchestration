# langgraph_app/enhanced_orchestration.py - ENTERPRISE FIXED VERSION
import asyncio
import logging
from typing import Dict, List, Optional, Any, Callable, TypedDict
from datetime import datetime
import uuid
from pathlib import Path
import time

from .enhanced_model_registry import EnhancedModelRegistry
from .style_profile_loader import StyleProfileLoader

# FIXED: Import only the agents that actually exist
logger = logging.getLogger(__name__)

class AgentState(TypedDict):
    """Complete state for enterprise workflow"""
    # Input data
    template_id: str
    style_profile: str
    parameters: Dict[str, Any]
    generation_id: str
    
    # Content progression
    content: str
    outline: Dict[str, Any]
    research_data: Dict[str, Any]
    draft_content: str
    edited_content: str
    seo_metadata: Dict[str, Any]
    
    # Workflow management
    current_agent: str
    completed_agents: List[str]
    failed_agents: List[str]
    overall_progress: float
    step_progress: Dict[str, float]
    
    # System data
    template_data: Dict[str, Any]
    style_data: Dict[str, Any]
    model_config: Dict[str, Any]
    
    # Results
    final_content: str
    metadata: Dict[str, Any]
    quality_score: Dict[str, Any]
    errors: List[Dict[str, Any]]

class EnhancedOrchestrator:
    """ENTERPRISE ORCHESTRATOR - Optimized for Profitability"""

    def __init__(self):
        self.model_registry = EnhancedModelRegistry()
        self.style_loader = StyleProfileLoader()
        
        # Initialize the REAL writer agent that exists
        self.writer_agent = None
        self._initialize_agents()
        
        logger.info("ğŸ¢ Enterprise Orchestrator initialized")

    def _initialize_agents(self):
        """Initialize available agents safely"""
        try:
            from .agents.writer import InnovativeWriterAgent
            self.writer_agent = InnovativeWriterAgent()
            logger.info("âœ… InnovativeWriterAgent loaded successfully")
        except ImportError as e:
            logger.error(f"âŒ Failed to load writer agent: {e}")
            raise Exception("Critical: Writer agent not available")

    async def generate_content(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
        """ENTERPRISE CONTENT GENERATION - Revenue-Optimized"""
        
        generation_id = str(uuid.uuid4())
        start_time = time.time()
        
        try:
            logger.info(f"ğŸš€ Starting ENTERPRISE generation {generation_id}")
            
            # Prepare enterprise state
            writer_state = {
                "template": request_data.get("template"),
                "style_profile": request_data.get("style_profile"),
                "dynamic_parameters": request_data.get("dynamic_parameters", {}),
                "topic": self._extract_topic(request_data),
                "audience": self._extract_audience(request_data),
                "platform": self._extract_platform(request_data),
                "innovation_level": self._extract_innovation_level(request_data),
                "use_mock": False,
                "generation_id": generation_id
            }
            
            # Add enterprise metadata
            writer_state["enterprise_metadata"] = {
                "generation_mode": "enterprise",
                "billing_enabled": True,
                "quality_tier": "premium",
                "started_at": datetime.now().isoformat()
            }
            
            # Execute premium generation
            logger.info(f"ğŸ“ Executing enterprise writing with InnovativeWriterAgent")
            result = self.writer_agent.generate_adaptive_content(writer_state)
            
            # Calculate generation metrics for billing
            generation_time = time.time() - start_time
            word_count = len(result.get("draft", "").split())
            
            # Enhanced enterprise response
            enterprise_result = {
                "success": True,
                "content": result.get("draft", ""),
                "metadata": {
                    **result.get("metadata", {}),
                    "generation_id": generation_id,
                    "generation_time": generation_time,
                    "word_count": word_count,
                    "enterprise_tier": "premium",
                    "innovation_report": result.get("innovation_report", {}),
                    "billing_metrics": {
                        "generation_time": generation_time,
                        "word_count": word_count,
                        "complexity_score": self._calculate_complexity_score(result),
                        "innovation_score": result.get("innovation_report", {}).get("creative_risk_score", 0),
                        "premium_features_used": result.get("innovation_report", {}).get("techniques_used", [])
                    }
                },
                "quality_score": {
                    "overall": 85 + (len(result.get("innovation_report", {}).get("techniques_used", [])) * 5),
                    "innovation": result.get("innovation_report", {}).get("creative_risk_score", 0) * 100,
                    "enterprise_grade": True
                },
                "generation_id": generation_id
            }
            
            logger.info(f"âœ… ENTERPRISE generation {generation_id} completed in {generation_time:.2f}s")
            logger.info(f"ğŸ’° Billable metrics: {word_count} words, innovation score: {enterprise_result['quality_score']['innovation']}")
            
            return enterprise_result
            
        except Exception as e:
            logger.error(f"âŒ ENTERPRISE generation {generation_id} failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "generation_id": generation_id,
                "metadata": {
                    "generation_time": time.time() - start_time,
                    "failure_mode": "enterprise_generation_error"
                }
            }

    def _extract_topic(self, request_data: Dict[str, Any]) -> str:
        """Extract topic with enterprise defaults"""
        params = request_data.get("dynamic_parameters", {})
        return (
            params.get("topic") or 
            request_data.get("topic") or 
            "Enterprise Content Generation"
        )

    def _extract_audience(self, request_data: Dict[str, Any]) -> str:
        """Extract audience with enterprise focus"""
        params = request_data.get("dynamic_parameters", {})
        return (
            params.get("audience") or 
            request_data.get("audience") or 
            "Professional Business Audience"
        )

    def _extract_platform(self, request_data: Dict[str, Any]) -> str:
        """Extract platform with enterprise defaults"""
        params = request_data.get("dynamic_parameters", {})
        return (
            params.get("platform") or 
            request_data.get("platform") or 
            "enterprise_blog"
        )

    def _extract_innovation_level(self, request_data: Dict[str, Any]) -> str:
        """Extract innovation level for premium features"""
        params = request_data.get("dynamic_parameters", {})
        return (
            params.get("innovation_level") or 
            "innovative"  # Default to premium tier
        )

    def _calculate_complexity_score(self, result: Dict[str, Any]) -> float:
        """Calculate complexity score for enterprise billing"""
        base_score = 0.5
        
        # Factor in innovation techniques
        techniques_used = result.get("innovation_report", {}).get("techniques_used", [])
        complexity_bonus = len(techniques_used) * 0.1
        
        # Factor in content length
        word_count = result.get("metadata", {}).get("word_count", 0)
        length_factor = min(word_count / 1000, 2.0) * 0.3
        
        return min(base_score + complexity_bonus + length_factor, 1.0)

# Create enhanced style loader for enterprise templates
class EnhancedStyleProfileLoader(StyleProfileLoader):
    """Enhanced loader with enterprise template support"""
    
    def __init__(self):
        super().__init__()
        self.templates_cache: Dict[str, Dict[str, Any]] = {}
        self.templates_path: Optional[Path] = None
        self._find_and_load_templates()
    
    def _find_and_load_templates(self):
        """Find and load content templates for enterprise use"""
        from pathlib import Path
        
        cwd = Path.cwd()
        search_paths = [
            cwd / "data" / "content_templates",
            cwd / "content_templates", 
            cwd / ".." / "data" / "content_templates",
            cwd / "frontend" / "content-templates"
        ]
        
        for path in search_paths:
            resolved_path = path.resolve()
            if resolved_path.exists() and resolved_path.is_dir():
                yaml_files = list(resolved_path.glob("*.yaml")) + list(resolved_path.glob("*.yml"))
                
                if yaml_files:
                    logger.info(f"ğŸ“ Found enterprise templates directory: {resolved_path}")
                    self.templates_path = resolved_path
                    self._load_templates_from_directory(resolved_path)
                    return
        
        logger.warning("âš ï¸ No enterprise templates directory found")
    
    def _load_templates_from_directory(self, directory: Path):
        """Load all template YAML files for enterprise use"""
        import yaml
        
        yaml_files = list(directory.glob("*.yaml")) + list(directory.glob("*.yml"))
        loaded_count = 0
        
        for yaml_file in yaml_files:
            try:
                with open(yaml_file, 'r', encoding='utf-8') as f:
                    template_data = yaml.safe_load(f)
                
                if template_data:
                    template_name = yaml_file.stem
                    self.templates_cache[template_name] = template_data
                    loaded_count += 1
                    
            except Exception as e:
                logger.error(f"âŒ Error loading enterprise template {yaml_file.name}: {e}")
        
        logger.info(f"ğŸ“Š Successfully loaded {loaded_count} enterprise templates")
    
    async def load_template(self, template_id: str) -> Optional[Dict[str, Any]]:
        """Load a specific enterprise template"""
        if template_id not in self.templates_cache:
            logger.warning(f"âš ï¸ Enterprise template '{template_id}' not found")
            return None
        return self.templates_cache[template_id]
    
    async def load_style_profile(self, profile_name: str) -> Optional[Dict[str, Any]]:
        """Load a style profile (async version) for enterprise use"""
        return self.get_profile(profile_name)

# Factory function for creating enterprise orchestrator
async def create_enhanced_orchestrator() -> EnhancedOrchestrator:
    """Create enterprise orchestrator for maximum profitability"""
    
    orchestrator = EnhancedOrchestrator()
    logger.info("ğŸ¢ Enterprise orchestrator created successfully")
    
    return orchestrator